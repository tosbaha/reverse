import plyara
import os
import re
import struct

def read_yara_rule(file_name):
    script_dir = os.path.dirname(os.path.abspath(__file__))
    file_path = os.path.join(script_dir, file_name)
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except FileNotFoundError:
        print(f"Error: File '{file_name}' not found in the script directory.")
        return None

def parse_yara_rule(rule_string):
    parser = plyara.Plyara()
    try:
        parsed_rules = parser.parse_string(rule_string)
        return parsed_rules[0]  # Assuming there's only one rule in the file
    except Exception as e:
        print(f"Error parsing YARA rule: {e}")
        return None

def parse_condition(condition_string):
    conditions = condition_string.split(' and ')
    parsed_conditions = []
    
    for cond in conditions:
        cond = cond.strip()
        
        # Parse filesize condition
        if cond.startswith('filesize'):
            parsed_conditions.append(('filesize', cond))
        
        # Parse hash condition
        elif cond.startswith('hash.'):
            parsed_conditions.append(('hash', cond))
        
        # Parse uint8 conditions
        elif cond.startswith('uint'):
            match = re.match(r'(uint(?:8|32))\s*\(\s*(\d+)\s*\)\s*([+\-*%&^])\s*(\d+)\s*==\s*(\d+)', cond)
            if match:
                uint_type, offset, operator, value1, value2 = match.groups()
                print(cond)
                parsed_conditions.append((uint_type, int(offset), operator, int(value1), '==', int(value2)))
        else:
            print("Unknown %s" % cond)
    
    return parsed_conditions

def analyze_yara_rule(file_name):
    rule_string = read_yara_rule(file_name)
    if rule_string is None:
        return
    
    parsed_rule = parse_yara_rule(rule_string)
    if parsed_rule is None:
        return
    
    print(f"Rule name: {parsed_rule.get('rule_name', 'Unknown')}")
    
    if 'metadata' in parsed_rule:
        print("Metadata:")
        for item in parsed_rule['metadata']:
            if isinstance(item, dict):
                for key, value in item.items():
                    print(f"  {key}: {value}")
            else:
                print(f"  {item}")
    
    if 'strings' in parsed_rule:
        # print("Strings:")
        for string in parsed_rule['strings']:
            if isinstance(string, dict):
                name = string.get('name', 'Unknown')
                value = string.get('value', 'Unknown')
                print(f"  ${name}: {value}")
            else:
                print(f"  {string}")
    
    if 'condition_terms' in parsed_rule:
        print("Conditions:")
        condition_string = ' '.join(str(term) for term in parsed_rule['condition_terms'])
        parsed_conditions = parse_condition(condition_string)
        
        byte_array = create_byte_array(parsed_conditions)
        
        print("\nGenerated byte array:")
        print(''.join(chr(b) if b != ord('#') else '#' for b in byte_array))

        # for i,byte in enumerate(byte_array):
        #     print(" %d %s" % (i,chr(byte)))

        
        # Write to file
        output_file = "output_85bytes.bin"
        with open(output_file, 'wb') as f:
            f.write(byte_array)

def solve_condition(condition):
    if condition[0] not in ['uint8', 'uint32']:
        return None
    
    uint_type, offset, operator, value1, _, value2 = condition
    if operator == '+':
        result = value2 - value1
    elif operator == '-':
        result = value1 + value2
    elif operator == '^':
        result = value1 ^ value2

    else:
        return None  # We're only handling + and - operations for now
    
    if uint_type == 'uint8':
        return offset, result & 0xFF
    elif uint_type == 'uint32':
        return offset, result & 0xFFFFFFFF
    
    return None

def create_byte_array(parsed_conditions):
    byte_array = bytearray([ord('#')] * 85)  # Initialize with placeholder characters
    
    for condition in parsed_conditions:
        solution = solve_condition(condition)
        if solution:
            offset, value = solution
            if condition[0] == 'uint8':
                byte_array[offset] = value
            elif condition[0] == 'uint32':
                struct.pack_into('<I', byte_array, offset, value)
    
    return byte_array


# Example usage
if __name__ == "__main__":
    yara_file_name = "clean.yara"
    analyze_yara_rule(yara_file_name)
